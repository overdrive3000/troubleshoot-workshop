"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystem = exports.ThroughputMode = exports.PerformanceMode = exports.OutOfInfrequentAccessPolicy = exports.LifecyclePolicy = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const ec2 = require("@aws-cdk/aws-ec2");
const iam = require("@aws-cdk/aws-iam");
const core_1 = require("@aws-cdk/core");
// keep this import separate from other imports to reduce chance for merge conflicts with v2-main
// eslint-disable-next-line no-duplicate-imports
const core_2 = require("@aws-cdk/core");
const cxapi = require("@aws-cdk/cx-api");
const access_point_1 = require("./access-point");
const efs_generated_1 = require("./efs.generated");
/**
 * EFS Lifecycle Policy, if a file is not accessed for given days, it will move to EFS Infrequent Access.
 *
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-filesystem.html#cfn-elasticfilesystem-filesystem-lifecyclepolicies
 */
var LifecyclePolicy;
(function (LifecyclePolicy) {
    /**
     * After 7 days of not being accessed.
     */
    LifecyclePolicy["AFTER_7_DAYS"] = "AFTER_7_DAYS";
    /**
     * After 14 days of not being accessed.
     */
    LifecyclePolicy["AFTER_14_DAYS"] = "AFTER_14_DAYS";
    /**
     * After 30 days of not being accessed.
     */
    LifecyclePolicy["AFTER_30_DAYS"] = "AFTER_30_DAYS";
    /**
     * After 60 days of not being accessed.
     */
    LifecyclePolicy["AFTER_60_DAYS"] = "AFTER_60_DAYS";
    /**
     * After 90 days of not being accessed.
     */
    LifecyclePolicy["AFTER_90_DAYS"] = "AFTER_90_DAYS";
})(LifecyclePolicy = exports.LifecyclePolicy || (exports.LifecyclePolicy = {}));
/**
 * EFS Out Of Infrequent Access Policy, if a file is accessed given times, it will move back to primary
 * storage class.
 *
 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-efs-filesystem-lifecyclepolicy.html#cfn-efs-filesystem-lifecyclepolicy-transitiontoprimarystorageclass
 */
var OutOfInfrequentAccessPolicy;
(function (OutOfInfrequentAccessPolicy) {
    /**
     * After 1 access
     */
    OutOfInfrequentAccessPolicy["AFTER_1_ACCESS"] = "AFTER_1_ACCESS";
})(OutOfInfrequentAccessPolicy = exports.OutOfInfrequentAccessPolicy || (exports.OutOfInfrequentAccessPolicy = {}));
/**
 * EFS Performance mode.
 *
 * @see https://docs.aws.amazon.com/efs/latest/ug/performance.html#performancemodes
 */
var PerformanceMode;
(function (PerformanceMode) {
    /**
     * General Purpose is ideal for latency-sensitive use cases, like web serving
     * environments, content management systems, home directories, and general file serving.
     * Recommended for the majority of Amazon EFS file systems.
     */
    PerformanceMode["GENERAL_PURPOSE"] = "generalPurpose";
    /**
     * File systems in the Max I/O mode can scale to higher levels of aggregate
     * throughput and operations per second. This scaling is done with a tradeoff
     * of slightly higher latencies for file metadata operations.
     * Highly parallelized applications and workloads, such as big data analysis,
     * media processing, and genomics analysis, can benefit from this mode.
     */
    PerformanceMode["MAX_IO"] = "maxIO";
})(PerformanceMode = exports.PerformanceMode || (exports.PerformanceMode = {}));
/**
 * EFS Throughput mode.
 *
 * @see https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes
 */
var ThroughputMode;
(function (ThroughputMode) {
    /**
     * This mode on Amazon EFS scales as the size of the file system in the standard storage class grows.
     */
    ThroughputMode["BURSTING"] = "bursting";
    /**
     * This mode can instantly provision the throughput of the file system (in MiB/s) independent of the amount of data stored.
     */
    ThroughputMode["PROVISIONED"] = "provisioned";
})(ThroughputMode = exports.ThroughputMode || (exports.ThroughputMode = {}));
class FileSystemBase extends core_1.Resource {
    /**
     * Grant the actions defined in actions to the given grantee
     * on this File System resource.
     *
     * @param grantee Principal to grant right to
     * @param actions The actions to grant
     */
    grant(grantee, ...actions) {
        return iam.Grant.addToPrincipal({
            grantee: grantee,
            actions: actions,
            resourceArns: [this.fileSystemArn],
        });
    }
}
/**
 * The Elastic File System implementation of IFileSystem.
 * It creates a new, empty file system in Amazon Elastic File System (Amazon EFS).
 * It also creates mount target (AWS::EFS::MountTarget) implicitly to mount the
 * EFS file system on an Amazon Elastic Compute Cloud (Amazon EC2) instance or another resource.
 *
 * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-filesystem.html
 *
 * @resource AWS::EFS::FileSystem
 */
class FileSystem extends FileSystemBase {
    /**
     * Constructor for creating a new EFS FileSystem.
     */
    constructor(scope, id, props) {
        var _b, _c, _d, _e;
        super(scope, id);
        this._mountTargetsAvailable = new core_1.ConcreteDependable();
        jsiiDeprecationWarnings._aws_cdk_aws_efs_FileSystemProps(props);
        if (props.throughputMode === ThroughputMode.PROVISIONED && props.provisionedThroughputPerSecond === undefined) {
            throw new Error('Property provisionedThroughputPerSecond is required when throughputMode is PROVISIONED');
        }
        // we explictly use 'undefined' to represent 'false' to maintain backwards compatibility since
        // its considered an actual change in CloudFormations eyes, even though they have the same meaning.
        const encrypted = (_b = props.encrypted) !== null && _b !== void 0 ? _b : (core_2.FeatureFlags.of(this).isEnabled(cxapi.EFS_DEFAULT_ENCRYPTION_AT_REST) ? true : undefined);
        const filesystem = new efs_generated_1.CfnFileSystem(this, 'Resource', {
            encrypted: encrypted,
            kmsKeyId: (_c = props.kmsKey) === null || _c === void 0 ? void 0 : _c.keyArn,
            lifecyclePolicies: ((props.lifecyclePolicy || props.outOfInfrequentAccessPolicy) ?
                [{
                        transitionToIa: props.lifecyclePolicy,
                        transitionToPrimaryStorageClass: props.outOfInfrequentAccessPolicy,
                    }] : undefined),
            performanceMode: props.performanceMode,
            throughputMode: props.throughputMode,
            provisionedThroughputInMibps: (_d = props.provisionedThroughputPerSecond) === null || _d === void 0 ? void 0 : _d.toMebibytes(),
            backupPolicy: props.enableAutomaticBackups ? { status: 'ENABLED' } : undefined,
        });
        filesystem.applyRemovalPolicy(props.removalPolicy);
        this.fileSystemId = filesystem.ref;
        this.fileSystemArn = filesystem.attrArn;
        core_1.Tags.of(this).add('Name', props.fileSystemName || this.node.path);
        const securityGroup = (props.securityGroup || new ec2.SecurityGroup(this, 'EfsSecurityGroup', {
            vpc: props.vpc,
        }));
        this.connections = new ec2.Connections({
            securityGroups: [securityGroup],
            defaultPort: ec2.Port.tcp(FileSystem.DEFAULT_PORT),
        });
        const subnets = props.vpc.selectSubnets((_e = props.vpcSubnets) !== null && _e !== void 0 ? _e : { onePerAz: true });
        // We now have to create the mount target for each of the mentioned subnet
        let mountTargetCount = 0;
        this.mountTargetsAvailable = [];
        subnets.subnetIds.forEach((subnetId) => {
            const mountTarget = new efs_generated_1.CfnMountTarget(this, 'EfsMountTarget' + (++mountTargetCount), {
                fileSystemId: this.fileSystemId,
                securityGroups: Array.of(securityGroup.securityGroupId),
                subnetId,
            });
            this._mountTargetsAvailable.add(mountTarget);
        });
        this.mountTargetsAvailable = this._mountTargetsAvailable;
    }
    /**
     * Import an existing File System from the given properties.
     */
    static fromFileSystemAttributes(scope, id, attrs) {
        jsiiDeprecationWarnings._aws_cdk_aws_efs_FileSystemAttributes(attrs);
        return new ImportedFileSystem(scope, id, attrs);
    }
    /**
     * create access point from this filesystem
     */
    addAccessPoint(id, accessPointOptions = {}) {
        jsiiDeprecationWarnings._aws_cdk_aws_efs_AccessPointOptions(accessPointOptions);
        return new access_point_1.AccessPoint(this, id, {
            fileSystem: this,
            ...accessPointOptions,
        });
    }
}
exports.FileSystem = FileSystem;
_a = JSII_RTTI_SYMBOL_1;
FileSystem[_a] = { fqn: "@aws-cdk/aws-efs.FileSystem", version: "1.147.0" };
/**
 * The default port File System listens on.
 */
FileSystem.DEFAULT_PORT = 2049;
class ImportedFileSystem extends FileSystemBase {
    constructor(scope, id, attrs) {
        var _b, _c;
        super(scope, id);
        if (!!attrs.fileSystemId === !!attrs.fileSystemArn) {
            throw new Error('One of fileSystemId or fileSystemArn, but not both, must be provided.');
        }
        this.fileSystemArn = (_b = attrs.fileSystemArn) !== null && _b !== void 0 ? _b : core_1.Stack.of(scope).formatArn({
            service: 'elasticfilesystem',
            resource: 'file-system',
            resourceName: attrs.fileSystemId,
        });
        const parsedArn = core_1.Stack.of(scope).splitArn(this.fileSystemArn, core_1.ArnFormat.SLASH_RESOURCE_NAME);
        if (!parsedArn.resourceName) {
            throw new Error(`Invalid FileSystem Arn ${this.fileSystemArn}`);
        }
        this.fileSystemId = (_c = attrs.fileSystemId) !== null && _c !== void 0 ? _c : parsedArn.resourceName;
        this.connections = new ec2.Connections({
            securityGroups: [attrs.securityGroup],
            defaultPort: ec2.Port.tcp(FileSystem.DEFAULT_PORT),
        });
        this.mountTargetsAvailable = new core_1.ConcreteDependable();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZzLWZpbGUtc3lzdGVtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWZzLWZpbGUtc3lzdGVtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFFeEMsd0NBQWtJO0FBQ2xJLGlHQUFpRztBQUNqRyxnREFBZ0Q7QUFDaEQsd0NBQTZDO0FBQzdDLHlDQUF5QztBQUV6QyxpREFBaUU7QUFDakUsbURBQWdFO0FBRWhFOzs7O0dBSUc7QUFDSCxJQUFZLGVBeUJYO0FBekJELFdBQVksZUFBZTtJQUN6Qjs7T0FFRztJQUNILGdEQUE2QixDQUFBO0lBRTdCOztPQUVHO0lBQ0gsa0RBQStCLENBQUE7SUFFL0I7O09BRUc7SUFDSCxrREFBK0IsQ0FBQTtJQUUvQjs7T0FFRztJQUNILGtEQUErQixDQUFBO0lBRS9COztPQUVHO0lBQ0gsa0RBQStCLENBQUE7QUFDakMsQ0FBQyxFQXpCVyxlQUFlLEdBQWYsdUJBQWUsS0FBZix1QkFBZSxRQXlCMUI7QUFFRDs7Ozs7R0FLRztBQUNILElBQVksMkJBS1g7QUFMRCxXQUFZLDJCQUEyQjtJQUNyQzs7T0FFRztJQUNILGdFQUFpQyxDQUFBO0FBQ25DLENBQUMsRUFMVywyQkFBMkIsR0FBM0IsbUNBQTJCLEtBQTNCLG1DQUEyQixRQUt0QztBQUVEOzs7O0dBSUc7QUFDSCxJQUFZLGVBZ0JYO0FBaEJELFdBQVksZUFBZTtJQUN6Qjs7OztPQUlHO0lBQ0gscURBQWtDLENBQUE7SUFFbEM7Ozs7OztPQU1HO0lBQ0gsbUNBQWdCLENBQUE7QUFDbEIsQ0FBQyxFQWhCVyxlQUFlLEdBQWYsdUJBQWUsS0FBZix1QkFBZSxRQWdCMUI7QUFFRDs7OztHQUlHO0FBQ0gsSUFBWSxjQVVYO0FBVkQsV0FBWSxjQUFjO0lBQ3hCOztPQUVHO0lBQ0gsdUNBQXFCLENBQUE7SUFFckI7O09BRUc7SUFDSCw2Q0FBMkIsQ0FBQTtBQUM3QixDQUFDLEVBVlcsY0FBYyxHQUFkLHNCQUFjLEtBQWQsc0JBQWMsUUFVekI7QUE0SkQsTUFBZSxjQUFlLFNBQVEsZUFBUTtJQW9CNUM7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLE9BQXVCLEVBQUUsR0FBRyxPQUFpQjtRQUN4RCxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDO1lBQzlCLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7U0FDbkMsQ0FBQyxDQUFDO0tBQ0o7Q0FDRjtBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsVUFBVyxTQUFRLGNBQWM7SUErQjVDOztPQUVHO0lBQ0gsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUFzQjs7UUFDOUQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQU5GLDJCQUFzQixHQUFHLElBQUkseUJBQWtCLEVBQUUsQ0FBQzs7UUFRakUsSUFBSSxLQUFLLENBQUMsY0FBYyxLQUFLLGNBQWMsQ0FBQyxXQUFXLElBQUksS0FBSyxDQUFDLDhCQUE4QixLQUFLLFNBQVMsRUFBRTtZQUM3RyxNQUFNLElBQUksS0FBSyxDQUFDLHdGQUF3RixDQUFDLENBQUM7U0FDM0c7UUFFRCw4RkFBOEY7UUFDOUYsbUdBQW1HO1FBQ25HLE1BQU0sU0FBUyxTQUFHLEtBQUssQ0FBQyxTQUFTLG1DQUFJLENBQUMsbUJBQVksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUNuRSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU1RCxNQUFNLFVBQVUsR0FBRyxJQUFJLDZCQUFhLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRTtZQUNyRCxTQUFTLEVBQUUsU0FBUztZQUNwQixRQUFRLFFBQUUsS0FBSyxDQUFDLE1BQU0sMENBQUUsTUFBTTtZQUM5QixpQkFBaUIsRUFBRSxDQUNqQixDQUFDLEtBQUssQ0FBQyxlQUFlLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQztnQkFDNUQsQ0FBQzt3QkFDQyxjQUFjLEVBQUUsS0FBSyxDQUFDLGVBQWU7d0JBQ3JDLCtCQUErQixFQUFFLEtBQUssQ0FBQywyQkFBMkI7cUJBQ25FLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBQ25CLGVBQWUsRUFBRSxLQUFLLENBQUMsZUFBZTtZQUN0QyxjQUFjLEVBQUUsS0FBSyxDQUFDLGNBQWM7WUFDcEMsNEJBQTRCLFFBQUUsS0FBSyxDQUFDLDhCQUE4QiwwQ0FBRSxXQUFXLEVBQUU7WUFDakYsWUFBWSxFQUFFLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVM7U0FDL0UsQ0FBQyxDQUFDO1FBQ0gsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUVuRCxJQUFJLENBQUMsWUFBWSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUM7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDO1FBRXhDLFdBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFbEUsTUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLElBQUksR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUU7WUFDNUYsR0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHO1NBQ2YsQ0FBQyxDQUFDLENBQUM7UUFFSixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQztZQUNyQyxjQUFjLEVBQUUsQ0FBQyxhQUFhLENBQUM7WUFDL0IsV0FBVyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUM7U0FDbkQsQ0FBQyxDQUFDO1FBRUgsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxhQUFhLE9BQUMsS0FBSyxDQUFDLFVBQVUsbUNBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUVoRiwwRUFBMEU7UUFDMUUsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEVBQUUsQ0FBQztRQUNoQyxPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRTtZQUM3QyxNQUFNLFdBQVcsR0FBRyxJQUFJLDhCQUFjLENBQUMsSUFBSSxFQUN6QyxnQkFBZ0IsR0FBRyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsRUFDdkM7Z0JBQ0UsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO2dCQUMvQixjQUFjLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDO2dCQUN2RCxRQUFRO2FBQ1QsQ0FBQyxDQUFDO1lBQ0wsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMvQyxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUM7S0FDMUQ7SUF0RkQ7O09BRUc7SUFDSSxNQUFNLENBQUMsd0JBQXdCLENBQUMsS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBMkI7O1FBQzlGLE9BQU8sSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ2pEO0lBbUZEOztPQUVHO0lBQ0ksY0FBYyxDQUFDLEVBQVUsRUFBRSxxQkFBeUMsRUFBRTs7UUFDM0UsT0FBTyxJQUFJLDBCQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRTtZQUMvQixVQUFVLEVBQUUsSUFBSTtZQUNoQixHQUFHLGtCQUFrQjtTQUN0QixDQUFDLENBQUM7S0FDSjs7QUF0R0gsZ0NBdUdDOzs7QUF0R0M7O0dBRUc7QUFDb0IsdUJBQVksR0FBVyxJQUFJLENBQUM7QUFxR3JELE1BQU0sa0JBQW1CLFNBQVEsY0FBYztJQXFCN0MsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUEyQjs7UUFDbkUsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVqQixJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsWUFBWSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFO1lBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsdUVBQXVFLENBQUMsQ0FBQztTQUMxRjtRQUVELElBQUksQ0FBQyxhQUFhLFNBQUcsS0FBSyxDQUFDLGFBQWEsbUNBQUksWUFBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDcEUsT0FBTyxFQUFFLG1CQUFtQjtZQUM1QixRQUFRLEVBQUUsYUFBYTtZQUN2QixZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVk7U0FDakMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxTQUFTLEdBQUcsWUFBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxnQkFBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFFOUYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDakU7UUFFRCxJQUFJLENBQUMsWUFBWSxTQUFHLEtBQUssQ0FBQyxZQUFZLG1DQUFJLFNBQVMsQ0FBQyxZQUFZLENBQUM7UUFFakUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFDckMsY0FBYyxFQUFFLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQztZQUNyQyxXQUFXLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQztTQUNuRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSx5QkFBa0IsRUFBRSxDQUFDO0tBQ3ZEO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBlYzIgZnJvbSAnQGF3cy1jZGsvYXdzLWVjMic7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSAnQGF3cy1jZGsvYXdzLWlhbSc7XG5pbXBvcnQgKiBhcyBrbXMgZnJvbSAnQGF3cy1jZGsvYXdzLWttcyc7XG5pbXBvcnQgeyBBcm5Gb3JtYXQsIENvbmNyZXRlRGVwZW5kYWJsZSwgSURlcGVuZGFibGUsIElSZXNvdXJjZSwgUmVtb3ZhbFBvbGljeSwgUmVzb3VyY2UsIFNpemUsIFN0YWNrLCBUYWdzIH0gZnJvbSAnQGF3cy1jZGsvY29yZSc7XG4vLyBrZWVwIHRoaXMgaW1wb3J0IHNlcGFyYXRlIGZyb20gb3RoZXIgaW1wb3J0cyB0byByZWR1Y2UgY2hhbmNlIGZvciBtZXJnZSBjb25mbGljdHMgd2l0aCB2Mi1tYWluXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwbGljYXRlLWltcG9ydHNcbmltcG9ydCB7IEZlYXR1cmVGbGFncyB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgQWNjZXNzUG9pbnQsIEFjY2Vzc1BvaW50T3B0aW9ucyB9IGZyb20gJy4vYWNjZXNzLXBvaW50JztcbmltcG9ydCB7IENmbkZpbGVTeXN0ZW0sIENmbk1vdW50VGFyZ2V0IH0gZnJvbSAnLi9lZnMuZ2VuZXJhdGVkJztcblxuLyoqXG4gKiBFRlMgTGlmZWN5Y2xlIFBvbGljeSwgaWYgYSBmaWxlIGlzIG5vdCBhY2Nlc3NlZCBmb3IgZ2l2ZW4gZGF5cywgaXQgd2lsbCBtb3ZlIHRvIEVGUyBJbmZyZXF1ZW50IEFjY2Vzcy5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWVmcy1maWxlc3lzdGVtLmh0bWwjY2ZuLWVsYXN0aWNmaWxlc3lzdGVtLWZpbGVzeXN0ZW0tbGlmZWN5Y2xlcG9saWNpZXNcbiAqL1xuZXhwb3J0IGVudW0gTGlmZWN5Y2xlUG9saWN5IHtcbiAgLyoqXG4gICAqIEFmdGVyIDcgZGF5cyBvZiBub3QgYmVpbmcgYWNjZXNzZWQuXG4gICAqL1xuICBBRlRFUl83X0RBWVMgPSAnQUZURVJfN19EQVlTJyxcblxuICAvKipcbiAgICogQWZ0ZXIgMTQgZGF5cyBvZiBub3QgYmVpbmcgYWNjZXNzZWQuXG4gICAqL1xuICBBRlRFUl8xNF9EQVlTID0gJ0FGVEVSXzE0X0RBWVMnLFxuXG4gIC8qKlxuICAgKiBBZnRlciAzMCBkYXlzIG9mIG5vdCBiZWluZyBhY2Nlc3NlZC5cbiAgICovXG4gIEFGVEVSXzMwX0RBWVMgPSAnQUZURVJfMzBfREFZUycsXG5cbiAgLyoqXG4gICAqIEFmdGVyIDYwIGRheXMgb2Ygbm90IGJlaW5nIGFjY2Vzc2VkLlxuICAgKi9cbiAgQUZURVJfNjBfREFZUyA9ICdBRlRFUl82MF9EQVlTJyxcblxuICAvKipcbiAgICogQWZ0ZXIgOTAgZGF5cyBvZiBub3QgYmVpbmcgYWNjZXNzZWQuXG4gICAqL1xuICBBRlRFUl85MF9EQVlTID0gJ0FGVEVSXzkwX0RBWVMnXG59XG5cbi8qKlxuICogRUZTIE91dCBPZiBJbmZyZXF1ZW50IEFjY2VzcyBQb2xpY3ksIGlmIGEgZmlsZSBpcyBhY2Nlc3NlZCBnaXZlbiB0aW1lcywgaXQgd2lsbCBtb3ZlIGJhY2sgdG8gcHJpbWFyeVxuICogc3RvcmFnZSBjbGFzcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2F3cy1wcm9wZXJ0aWVzLWVmcy1maWxlc3lzdGVtLWxpZmVjeWNsZXBvbGljeS5odG1sI2Nmbi1lZnMtZmlsZXN5c3RlbS1saWZlY3ljbGVwb2xpY3ktdHJhbnNpdGlvbnRvcHJpbWFyeXN0b3JhZ2VjbGFzc1xuICovXG5leHBvcnQgZW51bSBPdXRPZkluZnJlcXVlbnRBY2Nlc3NQb2xpY3kge1xuICAvKipcbiAgICogQWZ0ZXIgMSBhY2Nlc3NcbiAgICovXG4gIEFGVEVSXzFfQUNDRVNTID0gJ0FGVEVSXzFfQUNDRVNTJ1xufVxuXG4vKipcbiAqIEVGUyBQZXJmb3JtYW5jZSBtb2RlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Vmcy9sYXRlc3QvdWcvcGVyZm9ybWFuY2UuaHRtbCNwZXJmb3JtYW5jZW1vZGVzXG4gKi9cbmV4cG9ydCBlbnVtIFBlcmZvcm1hbmNlTW9kZSB7XG4gIC8qKlxuICAgKiBHZW5lcmFsIFB1cnBvc2UgaXMgaWRlYWwgZm9yIGxhdGVuY3ktc2Vuc2l0aXZlIHVzZSBjYXNlcywgbGlrZSB3ZWIgc2VydmluZ1xuICAgKiBlbnZpcm9ubWVudHMsIGNvbnRlbnQgbWFuYWdlbWVudCBzeXN0ZW1zLCBob21lIGRpcmVjdG9yaWVzLCBhbmQgZ2VuZXJhbCBmaWxlIHNlcnZpbmcuXG4gICAqIFJlY29tbWVuZGVkIGZvciB0aGUgbWFqb3JpdHkgb2YgQW1hem9uIEVGUyBmaWxlIHN5c3RlbXMuXG4gICAqL1xuICBHRU5FUkFMX1BVUlBPU0UgPSAnZ2VuZXJhbFB1cnBvc2UnLFxuXG4gIC8qKlxuICAgKiBGaWxlIHN5c3RlbXMgaW4gdGhlIE1heCBJL08gbW9kZSBjYW4gc2NhbGUgdG8gaGlnaGVyIGxldmVscyBvZiBhZ2dyZWdhdGVcbiAgICogdGhyb3VnaHB1dCBhbmQgb3BlcmF0aW9ucyBwZXIgc2Vjb25kLiBUaGlzIHNjYWxpbmcgaXMgZG9uZSB3aXRoIGEgdHJhZGVvZmZcbiAgICogb2Ygc2xpZ2h0bHkgaGlnaGVyIGxhdGVuY2llcyBmb3IgZmlsZSBtZXRhZGF0YSBvcGVyYXRpb25zLlxuICAgKiBIaWdobHkgcGFyYWxsZWxpemVkIGFwcGxpY2F0aW9ucyBhbmQgd29ya2xvYWRzLCBzdWNoIGFzIGJpZyBkYXRhIGFuYWx5c2lzLFxuICAgKiBtZWRpYSBwcm9jZXNzaW5nLCBhbmQgZ2Vub21pY3MgYW5hbHlzaXMsIGNhbiBiZW5lZml0IGZyb20gdGhpcyBtb2RlLlxuICAgKi9cbiAgTUFYX0lPID0gJ21heElPJ1xufVxuXG4vKipcbiAqIEVGUyBUaHJvdWdocHV0IG1vZGUuXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZWZzL2xhdGVzdC91Zy9wZXJmb3JtYW5jZS5odG1sI3Rocm91Z2hwdXQtbW9kZXNcbiAqL1xuZXhwb3J0IGVudW0gVGhyb3VnaHB1dE1vZGUge1xuICAvKipcbiAgICogVGhpcyBtb2RlIG9uIEFtYXpvbiBFRlMgc2NhbGVzIGFzIHRoZSBzaXplIG9mIHRoZSBmaWxlIHN5c3RlbSBpbiB0aGUgc3RhbmRhcmQgc3RvcmFnZSBjbGFzcyBncm93cy5cbiAgICovXG4gIEJVUlNUSU5HID0gJ2J1cnN0aW5nJyxcblxuICAvKipcbiAgICogVGhpcyBtb2RlIGNhbiBpbnN0YW50bHkgcHJvdmlzaW9uIHRoZSB0aHJvdWdocHV0IG9mIHRoZSBmaWxlIHN5c3RlbSAoaW4gTWlCL3MpIGluZGVwZW5kZW50IG9mIHRoZSBhbW91bnQgb2YgZGF0YSBzdG9yZWQuXG4gICAqL1xuICBQUk9WSVNJT05FRCA9ICdwcm92aXNpb25lZCdcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEFtYXpvbiBFRlMgZmlsZSBzeXN0ZW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRmlsZVN5c3RlbSBleHRlbmRzIGVjMi5JQ29ubmVjdGFibGUsIElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGZpbGUgc3lzdGVtLCBhc3NpZ25lZCBieSBBbWF6b24gRUZTLlxuICAgKlxuICAgKiBAYXR0cmlidXRlXG4gICAqL1xuICByZWFkb25seSBmaWxlU3lzdGVtSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIEFSTiBvZiB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqXG4gICAqIEBhdHRyaWJ1dGVcbiAgICovXG4gIHJlYWRvbmx5IGZpbGVTeXN0ZW1Bcm46IHN0cmluZztcblxuICAvKipcbiAgICogRGVwZW5kYWJsZSB0aGF0IGNhbiBiZSBkZXBlbmRlZCB1cG9uIHRvIGVuc3VyZSB0aGUgbW91bnQgdGFyZ2V0cyBvZiB0aGUgZmlsZXN5c3RlbSBhcmUgcmVhZHlcbiAgICovXG4gIHJlYWRvbmx5IG1vdW50VGFyZ2V0c0F2YWlsYWJsZTogSURlcGVuZGFibGU7XG5cbiAgLyoqXG4gICAqIEdyYW50IHRoZSBhY3Rpb25zIGRlZmluZWQgaW4gYWN0aW9ucyB0byB0aGUgZ2l2ZW4gZ3JhbnRlZVxuICAgKiBvbiB0aGlzIEZpbGUgU3lzdGVtIHJlc291cmNlLlxuICAgKi9cbiAgZ3JhbnQoZ3JhbnRlZTogaWFtLklHcmFudGFibGUsIC4uLmFjdGlvbnM6IHN0cmluZ1tdKTogaWFtLkdyYW50O1xufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgRUZTIEZpbGVTeXN0ZW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVN5c3RlbVByb3BzIHtcblxuICAvKipcbiAgICogVlBDIHRvIGxhdW5jaCB0aGUgZmlsZSBzeXN0ZW0gaW4uXG4gICAqL1xuICByZWFkb25seSB2cGM6IGVjMi5JVnBjO1xuXG4gIC8qKlxuICAgKiBTZWN1cml0eSBHcm91cCB0byBhc3NpZ24gdG8gdGhpcyBmaWxlIHN5c3RlbS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBjcmVhdGVzIG5ldyBzZWN1cml0eSBncm91cCB3aGljaCBhbGxvd3MgYWxsIG91dGJvdW5kIHRyYWZmaWNcbiAgICovXG4gIHJlYWRvbmx5IHNlY3VyaXR5R3JvdXA/OiBlYzIuSVNlY3VyaXR5R3JvdXA7XG5cbiAgLyoqXG4gICAqIFdoaWNoIHN1Ym5ldHMgdG8gcGxhY2UgdGhlIG1vdW50IHRhcmdldCBpbiB0aGUgVlBDLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHRoZSBWcGMgZGVmYXVsdCBzdHJhdGVneSBpZiBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICByZWFkb25seSB2cGNTdWJuZXRzPzogZWMyLlN1Ym5ldFNlbGVjdGlvbjtcblxuICAvKipcbiAgICogRGVmaW5lcyBpZiB0aGUgZGF0YSBhdCByZXN0IGluIHRoZSBmaWxlIHN5c3RlbSBpcyBlbmNyeXB0ZWQgb3Igbm90LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIElmIHlvdXIgYXBwbGljYXRpb24gaGFzIHRoZSAnQGF3cy1jZGsvYXdzLWVmczpkZWZhdWx0RW5jcnlwdGlvbkF0UmVzdCcgZmVhdHVyZSBmbGFnIHNldCwgdGhlIGRlZmF1bHQgaXMgdHJ1ZSwgb3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQGxpbmsgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay9sYXRlc3QvZ3VpZGUvZmVhdHVyZWZsYWdzLmh0bWxcbiAgICovXG4gIHJlYWRvbmx5IGVuY3J5cHRlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIHN5c3RlbSdzIG5hbWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ0RLIGdlbmVyYXRlZCBuYW1lXG4gICAqL1xuICByZWFkb25seSBmaWxlU3lzdGVtTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIEtNUyBrZXkgdXNlZCBmb3IgZW5jcnlwdGlvbi4gVGhpcyBpcyByZXF1aXJlZCB0byBlbmNyeXB0IHRoZSBkYXRhIGF0IHJlc3QgaWYgQGVuY3J5cHRlZCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBpZiAnZW5jcnlwdGVkJyBpcyB0cnVlLCB0aGUgZGVmYXVsdCBrZXkgZm9yIEVGUyAoL2F3cy9lbGFzdGljZmlsZXN5c3RlbSkgaXMgdXNlZFxuICAgKi9cbiAgcmVhZG9ubHkga21zS2V5Pzoga21zLklLZXk7XG5cbiAgLyoqXG4gICAqIEEgcG9saWN5IHVzZWQgYnkgRUZTIGxpZmVjeWNsZSBtYW5hZ2VtZW50IHRvIHRyYW5zaXRpb24gZmlsZXMgdG8gdGhlIEluZnJlcXVlbnQgQWNjZXNzIChJQSkgc3RvcmFnZSBjbGFzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBOb25lLiBFRlMgd2lsbCBub3QgdHJhbnNpdGlvbiBmaWxlcyB0byB0aGUgSUEgc3RvcmFnZSBjbGFzcy5cbiAgICovXG4gIHJlYWRvbmx5IGxpZmVjeWNsZVBvbGljeT86IExpZmVjeWNsZVBvbGljeTtcblxuICAvKipcbiAgICogQSBwb2xpY3kgdXNlZCBieSBFRlMgbGlmZWN5Y2xlIG1hbmFnZW1lbnQgdG8gdHJhbnNpdGlvbiBmaWxlcyBmcm9tIEluZnJlcXVlbnQgQWNjZXNzIChJQSkgc3RvcmFnZSBjbGFzcyB0b1xuICAgKiBwcmltYXJ5IHN0b3JhZ2UgY2xhc3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm9uZS4gRUZTIHdpbGwgbm90IHRyYW5zaXRpb24gZmlsZXMgZnJvbSBJQSBzdG9yYWdlIHRvIHByaW1hcnkgc3RvcmFnZS5cbiAgICovXG4gIHJlYWRvbmx5IG91dE9mSW5mcmVxdWVudEFjY2Vzc1BvbGljeT86IE91dE9mSW5mcmVxdWVudEFjY2Vzc1BvbGljeTtcbiAgLyoqXG4gICAqIFRoZSBwZXJmb3JtYW5jZSBtb2RlIHRoYXQgdGhlIGZpbGUgc3lzdGVtIHdpbGwgb3BlcmF0ZSB1bmRlci5cbiAgICogQW4gQW1hem9uIEVGUyBmaWxlIHN5c3RlbSdzIHBlcmZvcm1hbmNlIG1vZGUgY2FuJ3QgYmUgY2hhbmdlZCBhZnRlciB0aGUgZmlsZSBzeXN0ZW0gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICogVXBkYXRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHJlcGxhY2UgdGhlIGZpbGUgc3lzdGVtLlxuICAgKlxuICAgKiBAZGVmYXVsdCBQZXJmb3JtYW5jZU1vZGUuR0VORVJBTF9QVVJQT1NFXG4gICAqL1xuICByZWFkb25seSBwZXJmb3JtYW5jZU1vZGU/OiBQZXJmb3JtYW5jZU1vZGU7XG5cbiAgLyoqXG4gICAqIEVudW0gdG8gbWVudGlvbiB0aGUgdGhyb3VnaHB1dCBtb2RlIG9mIHRoZSBmaWxlIHN5c3RlbS5cbiAgICpcbiAgICogQGRlZmF1bHQgVGhyb3VnaHB1dE1vZGUuQlVSU1RJTkdcbiAgICovXG4gIHJlYWRvbmx5IHRocm91Z2hwdXRNb2RlPzogVGhyb3VnaHB1dE1vZGU7XG5cbiAgLyoqXG4gICAqIFByb3Zpc2lvbmVkIHRocm91Z2hwdXQgZm9yIHRoZSBmaWxlIHN5c3RlbS5cbiAgICogVGhpcyBpcyBhIHJlcXVpcmVkIHByb3BlcnR5IGlmIHRoZSB0aHJvdWdocHV0IG1vZGUgaXMgc2V0IHRvIFBST1ZJU0lPTkVELlxuICAgKiBNdXN0IGJlIGF0IGxlYXN0IDFNaUIvcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBub25lLCBlcnJvcnMgb3V0XG4gICAqL1xuICByZWFkb25seSBwcm92aXNpb25lZFRocm91Z2hwdXRQZXJTZWNvbmQ/OiBTaXplO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVtb3ZhbCBwb2xpY3kgdG8gYXBwbHkgdG8gdGhlIGZpbGUgc3lzdGVtLlxuICAgKlxuICAgKiBAZGVmYXVsdCBSZW1vdmFsUG9saWN5LlJFVEFJTlxuICAgKi9cbiAgcmVhZG9ubHkgcmVtb3ZhbFBvbGljeT86IFJlbW92YWxQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGF1dG9tYXRpYyBiYWNrdXBzIGZvciB0aGUgZmlsZSBzeXN0ZW0uXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBlbmFibGVBdXRvbWF0aWNCYWNrdXBzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgZGVzY3JpYmUgYW4gZXhpc3RpbmcgRUZTIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTeXN0ZW1BdHRyaWJ1dGVzIHtcbiAgLyoqXG4gICAqIFRoZSBzZWN1cml0eSBncm91cCBvZiB0aGUgZmlsZSBzeXN0ZW1cbiAgICovXG4gIHJlYWRvbmx5IHNlY3VyaXR5R3JvdXA6IGVjMi5JU2VjdXJpdHlHcm91cDtcblxuICAvKipcbiAgICogVGhlIEZpbGUgU3lzdGVtJ3MgSUQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGV0ZXJtaW5lZCBiYXNlZCBvbiBmaWxlU3lzdGVtQXJuXG4gICAqL1xuICByZWFkb25seSBmaWxlU3lzdGVtSWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBGaWxlIFN5c3RlbSdzIEFybi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZXRlcm1pbmVkIGJhc2VkIG9uIGZpbGVTeXN0ZW1JZFxuICAgKi9cbiAgcmVhZG9ubHkgZmlsZVN5c3RlbUFybj86IHN0cmluZztcbn1cblxuYWJzdHJhY3QgY2xhc3MgRmlsZVN5c3RlbUJhc2UgZXh0ZW5kcyBSZXNvdXJjZSBpbXBsZW1lbnRzIElGaWxlU3lzdGVtIHtcbiAgLyoqXG4gICAqIFRoZSBzZWN1cml0eSBncm91cHMvcnVsZXMgdXNlZCB0byBhbGxvdyBuZXR3b3JrIGNvbm5lY3Rpb25zIHRvIHRoZSBmaWxlIHN5c3RlbS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBjb25uZWN0aW9uczogZWMyLkNvbm5lY3Rpb25zO1xuXG4gIC8qKlxuICAqIEBhdHRyaWJ1dGVcbiAgKi9cbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGZpbGVTeXN0ZW1JZDogc3RyaW5nO1xuICAvKipcbiAgKiBAYXR0cmlidXRlXG4gICovXG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBmaWxlU3lzdGVtQXJuOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlcGVuZGFibGUgdGhhdCBjYW4gYmUgZGVwZW5kZWQgdXBvbiB0byBlbnN1cmUgdGhlIG1vdW50IHRhcmdldHMgb2YgdGhlIGZpbGVzeXN0ZW0gYXJlIHJlYWR5XG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgbW91bnRUYXJnZXRzQXZhaWxhYmxlOiBJRGVwZW5kYWJsZTtcblxuICAvKipcbiAgICogR3JhbnQgdGhlIGFjdGlvbnMgZGVmaW5lZCBpbiBhY3Rpb25zIHRvIHRoZSBnaXZlbiBncmFudGVlXG4gICAqIG9uIHRoaXMgRmlsZSBTeXN0ZW0gcmVzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSBncmFudGVlIFByaW5jaXBhbCB0byBncmFudCByaWdodCB0b1xuICAgKiBAcGFyYW0gYWN0aW9ucyBUaGUgYWN0aW9ucyB0byBncmFudFxuICAgKi9cbiAgcHVibGljIGdyYW50KGdyYW50ZWU6IGlhbS5JR3JhbnRhYmxlLCAuLi5hY3Rpb25zOiBzdHJpbmdbXSk6IGlhbS5HcmFudCB7XG4gICAgcmV0dXJuIGlhbS5HcmFudC5hZGRUb1ByaW5jaXBhbCh7XG4gICAgICBncmFudGVlOiBncmFudGVlLFxuICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgIHJlc291cmNlQXJuczogW3RoaXMuZmlsZVN5c3RlbUFybl0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgRWxhc3RpYyBGaWxlIFN5c3RlbSBpbXBsZW1lbnRhdGlvbiBvZiBJRmlsZVN5c3RlbS5cbiAqIEl0IGNyZWF0ZXMgYSBuZXcsIGVtcHR5IGZpbGUgc3lzdGVtIGluIEFtYXpvbiBFbGFzdGljIEZpbGUgU3lzdGVtIChBbWF6b24gRUZTKS5cbiAqIEl0IGFsc28gY3JlYXRlcyBtb3VudCB0YXJnZXQgKEFXUzo6RUZTOjpNb3VudFRhcmdldCkgaW1wbGljaXRseSB0byBtb3VudCB0aGVcbiAqIEVGUyBmaWxlIHN5c3RlbSBvbiBhbiBBbWF6b24gRWxhc3RpYyBDb21wdXRlIENsb3VkIChBbWF6b24gRUMyKSBpbnN0YW5jZSBvciBhbm90aGVyIHJlc291cmNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWVmcy1maWxlc3lzdGVtLmh0bWxcbiAqXG4gKiBAcmVzb3VyY2UgQVdTOjpFRlM6OkZpbGVTeXN0ZW1cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVTeXN0ZW0gZXh0ZW5kcyBGaWxlU3lzdGVtQmFzZSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBwb3J0IEZpbGUgU3lzdGVtIGxpc3RlbnMgb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfUE9SVDogbnVtYmVyID0gMjA0OTtcblxuICAvKipcbiAgICogSW1wb3J0IGFuIGV4aXN0aW5nIEZpbGUgU3lzdGVtIGZyb20gdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21GaWxlU3lzdGVtQXR0cmlidXRlcyhzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBhdHRyczogRmlsZVN5c3RlbUF0dHJpYnV0ZXMpOiBJRmlsZVN5c3RlbSB7XG4gICAgcmV0dXJuIG5ldyBJbXBvcnRlZEZpbGVTeXN0ZW0oc2NvcGUsIGlkLCBhdHRycyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNlY3VyaXR5IGdyb3Vwcy9ydWxlcyB1c2VkIHRvIGFsbG93IG5ldHdvcmsgY29ubmVjdGlvbnMgdG8gdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBlYzIuQ29ubmVjdGlvbnM7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGVcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmaWxlU3lzdGVtSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGVcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmaWxlU3lzdGVtQXJuOiBzdHJpbmc7XG5cbiAgcHVibGljIHJlYWRvbmx5IG1vdW50VGFyZ2V0c0F2YWlsYWJsZTogSURlcGVuZGFibGU7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbW91bnRUYXJnZXRzQXZhaWxhYmxlID0gbmV3IENvbmNyZXRlRGVwZW5kYWJsZSgpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYSBuZXcgRUZTIEZpbGVTeXN0ZW0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogRmlsZVN5c3RlbVByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcblxuICAgIGlmIChwcm9wcy50aHJvdWdocHV0TW9kZSA9PT0gVGhyb3VnaHB1dE1vZGUuUFJPVklTSU9ORUQgJiYgcHJvcHMucHJvdmlzaW9uZWRUaHJvdWdocHV0UGVyU2Vjb25kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgcHJvdmlzaW9uZWRUaHJvdWdocHV0UGVyU2Vjb25kIGlzIHJlcXVpcmVkIHdoZW4gdGhyb3VnaHB1dE1vZGUgaXMgUFJPVklTSU9ORUQnKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBleHBsaWN0bHkgdXNlICd1bmRlZmluZWQnIHRvIHJlcHJlc2VudCAnZmFsc2UnIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHNpbmNlXG4gICAgLy8gaXRzIGNvbnNpZGVyZWQgYW4gYWN0dWFsIGNoYW5nZSBpbiBDbG91ZEZvcm1hdGlvbnMgZXllcywgZXZlbiB0aG91Z2ggdGhleSBoYXZlIHRoZSBzYW1lIG1lYW5pbmcuXG4gICAgY29uc3QgZW5jcnlwdGVkID0gcHJvcHMuZW5jcnlwdGVkID8/IChGZWF0dXJlRmxhZ3Mub2YodGhpcykuaXNFbmFibGVkKFxuICAgICAgY3hhcGkuRUZTX0RFRkFVTFRfRU5DUllQVElPTl9BVF9SRVNUKSA/IHRydWUgOiB1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgZmlsZXN5c3RlbSA9IG5ldyBDZm5GaWxlU3lzdGVtKHRoaXMsICdSZXNvdXJjZScsIHtcbiAgICAgIGVuY3J5cHRlZDogZW5jcnlwdGVkLFxuICAgICAga21zS2V5SWQ6IHByb3BzLmttc0tleT8ua2V5QXJuLFxuICAgICAgbGlmZWN5Y2xlUG9saWNpZXM6IChcbiAgICAgICAgKHByb3BzLmxpZmVjeWNsZVBvbGljeSB8fCBwcm9wcy5vdXRPZkluZnJlcXVlbnRBY2Nlc3NQb2xpY3kpID9cbiAgICAgICAgICBbe1xuICAgICAgICAgICAgdHJhbnNpdGlvblRvSWE6IHByb3BzLmxpZmVjeWNsZVBvbGljeSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25Ub1ByaW1hcnlTdG9yYWdlQ2xhc3M6IHByb3BzLm91dE9mSW5mcmVxdWVudEFjY2Vzc1BvbGljeSxcbiAgICAgICAgICB9XSA6IHVuZGVmaW5lZCksXG4gICAgICBwZXJmb3JtYW5jZU1vZGU6IHByb3BzLnBlcmZvcm1hbmNlTW9kZSxcbiAgICAgIHRocm91Z2hwdXRNb2RlOiBwcm9wcy50aHJvdWdocHV0TW9kZSxcbiAgICAgIHByb3Zpc2lvbmVkVGhyb3VnaHB1dEluTWlicHM6IHByb3BzLnByb3Zpc2lvbmVkVGhyb3VnaHB1dFBlclNlY29uZD8udG9NZWJpYnl0ZXMoKSxcbiAgICAgIGJhY2t1cFBvbGljeTogcHJvcHMuZW5hYmxlQXV0b21hdGljQmFja3VwcyA/IHsgc3RhdHVzOiAnRU5BQkxFRCcgfSA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICBmaWxlc3lzdGVtLmFwcGx5UmVtb3ZhbFBvbGljeShwcm9wcy5yZW1vdmFsUG9saWN5KTtcblxuICAgIHRoaXMuZmlsZVN5c3RlbUlkID0gZmlsZXN5c3RlbS5yZWY7XG4gICAgdGhpcy5maWxlU3lzdGVtQXJuID0gZmlsZXN5c3RlbS5hdHRyQXJuO1xuXG4gICAgVGFncy5vZih0aGlzKS5hZGQoJ05hbWUnLCBwcm9wcy5maWxlU3lzdGVtTmFtZSB8fCB0aGlzLm5vZGUucGF0aCk7XG5cbiAgICBjb25zdCBzZWN1cml0eUdyb3VwID0gKHByb3BzLnNlY3VyaXR5R3JvdXAgfHwgbmV3IGVjMi5TZWN1cml0eUdyb3VwKHRoaXMsICdFZnNTZWN1cml0eUdyb3VwJywge1xuICAgICAgdnBjOiBwcm9wcy52cGMsXG4gICAgfSkpO1xuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBlYzIuQ29ubmVjdGlvbnMoe1xuICAgICAgc2VjdXJpdHlHcm91cHM6IFtzZWN1cml0eUdyb3VwXSxcbiAgICAgIGRlZmF1bHRQb3J0OiBlYzIuUG9ydC50Y3AoRmlsZVN5c3RlbS5ERUZBVUxUX1BPUlQpLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3VibmV0cyA9IHByb3BzLnZwYy5zZWxlY3RTdWJuZXRzKHByb3BzLnZwY1N1Ym5ldHMgPz8geyBvbmVQZXJBejogdHJ1ZSB9KTtcblxuICAgIC8vIFdlIG5vdyBoYXZlIHRvIGNyZWF0ZSB0aGUgbW91bnQgdGFyZ2V0IGZvciBlYWNoIG9mIHRoZSBtZW50aW9uZWQgc3VibmV0XG4gICAgbGV0IG1vdW50VGFyZ2V0Q291bnQgPSAwO1xuICAgIHRoaXMubW91bnRUYXJnZXRzQXZhaWxhYmxlID0gW107XG4gICAgc3VibmV0cy5zdWJuZXRJZHMuZm9yRWFjaCgoc3VibmV0SWQ6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbW91bnRUYXJnZXQgPSBuZXcgQ2ZuTW91bnRUYXJnZXQodGhpcyxcbiAgICAgICAgJ0Vmc01vdW50VGFyZ2V0JyArICgrK21vdW50VGFyZ2V0Q291bnQpLFxuICAgICAgICB7XG4gICAgICAgICAgZmlsZVN5c3RlbUlkOiB0aGlzLmZpbGVTeXN0ZW1JZCxcbiAgICAgICAgICBzZWN1cml0eUdyb3VwczogQXJyYXkub2Yoc2VjdXJpdHlHcm91cC5zZWN1cml0eUdyb3VwSWQpLFxuICAgICAgICAgIHN1Ym5ldElkLFxuICAgICAgICB9KTtcbiAgICAgIHRoaXMuX21vdW50VGFyZ2V0c0F2YWlsYWJsZS5hZGQobW91bnRUYXJnZXQpO1xuICAgIH0pO1xuICAgIHRoaXMubW91bnRUYXJnZXRzQXZhaWxhYmxlID0gdGhpcy5fbW91bnRUYXJnZXRzQXZhaWxhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhY2Nlc3MgcG9pbnQgZnJvbSB0aGlzIGZpbGVzeXN0ZW1cbiAgICovXG4gIHB1YmxpYyBhZGRBY2Nlc3NQb2ludChpZDogc3RyaW5nLCBhY2Nlc3NQb2ludE9wdGlvbnM6IEFjY2Vzc1BvaW50T3B0aW9ucyA9IHt9KTogQWNjZXNzUG9pbnQge1xuICAgIHJldHVybiBuZXcgQWNjZXNzUG9pbnQodGhpcywgaWQsIHtcbiAgICAgIGZpbGVTeXN0ZW06IHRoaXMsXG4gICAgICAuLi5hY2Nlc3NQb2ludE9wdGlvbnMsXG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgSW1wb3J0ZWRGaWxlU3lzdGVtIGV4dGVuZHMgRmlsZVN5c3RlbUJhc2Uge1xuICAvKipcbiAgICogVGhlIHNlY3VyaXR5IGdyb3Vwcy9ydWxlcyB1c2VkIHRvIGFsbG93IG5ldHdvcmsgY29ubmVjdGlvbnMgdG8gdGhlIGZpbGUgc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbm5lY3Rpb25zOiBlYzIuQ29ubmVjdGlvbnM7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGVcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBmaWxlU3lzdGVtSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGZpbGVTeXN0ZW1Bcm46IHN0cmluZztcblxuICAvKipcbiAgICogRGVwZW5kYWJsZSB0aGF0IGNhbiBiZSBkZXBlbmRlZCB1cG9uIHRvIGVuc3VyZSB0aGUgbW91bnQgdGFyZ2V0cyBvZiB0aGUgZmlsZXN5c3RlbSBhcmUgcmVhZHlcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtb3VudFRhcmdldHNBdmFpbGFibGU6IElEZXBlbmRhYmxlO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIGF0dHJzOiBGaWxlU3lzdGVtQXR0cmlidXRlcykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICBpZiAoISFhdHRycy5maWxlU3lzdGVtSWQgPT09ICEhYXR0cnMuZmlsZVN5c3RlbUFybikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgZmlsZVN5c3RlbUlkIG9yIGZpbGVTeXN0ZW1Bcm4sIGJ1dCBub3QgYm90aCwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGVTeXN0ZW1Bcm4gPSBhdHRycy5maWxlU3lzdGVtQXJuID8/IFN0YWNrLm9mKHNjb3BlKS5mb3JtYXRBcm4oe1xuICAgICAgc2VydmljZTogJ2VsYXN0aWNmaWxlc3lzdGVtJyxcbiAgICAgIHJlc291cmNlOiAnZmlsZS1zeXN0ZW0nLFxuICAgICAgcmVzb3VyY2VOYW1lOiBhdHRycy5maWxlU3lzdGVtSWQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBwYXJzZWRBcm4gPSBTdGFjay5vZihzY29wZSkuc3BsaXRBcm4odGhpcy5maWxlU3lzdGVtQXJuLCBBcm5Gb3JtYXQuU0xBU0hfUkVTT1VSQ0VfTkFNRSk7XG5cbiAgICBpZiAoIXBhcnNlZEFybi5yZXNvdXJjZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBGaWxlU3lzdGVtIEFybiAke3RoaXMuZmlsZVN5c3RlbUFybn1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbGVTeXN0ZW1JZCA9IGF0dHJzLmZpbGVTeXN0ZW1JZCA/PyBwYXJzZWRBcm4ucmVzb3VyY2VOYW1lO1xuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IG5ldyBlYzIuQ29ubmVjdGlvbnMoe1xuICAgICAgc2VjdXJpdHlHcm91cHM6IFthdHRycy5zZWN1cml0eUdyb3VwXSxcbiAgICAgIGRlZmF1bHRQb3J0OiBlYzIuUG9ydC50Y3AoRmlsZVN5c3RlbS5ERUZBVUxUX1BPUlQpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tb3VudFRhcmdldHNBdmFpbGFibGUgPSBuZXcgQ29uY3JldGVEZXBlbmRhYmxlKCk7XG4gIH1cbn0iXX0=